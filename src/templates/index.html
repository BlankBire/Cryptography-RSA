<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RSA Demo</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .container {
            max-width: 800px;
        }

        .result-box {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-top: 10px;
            word-break: break-all;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1 class="text-center mb-4">RSA Cryptanalysis Tool</h1>

        <!-- Key Generation Section -->
        <div class="card mb-4">
            <div class="card-header">
                <h2 class="h5 mb-0">Key Generation</h2>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <div class="form-group">
                            <label for="keySize">Key Size (bits)</label>
                            <select class="form-control" id="keySize">
                                <option value="2048">2048 bits</option>
                                <option value="3072">3072 bits</option>
                                <option value="4096">4096 bits</option>
                            </select>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="form-group">
                            <label>Public Exponent</label>
                            <div class="form-control bg-light">
                                16777217
                            </div>
                        </div>
                    </div>
                </div>
                <button class="btn btn-primary" onclick="generateKeys()">Generate New Keys</button>
                <div id="keyGenerationResult" class="mt-3" style="display: none;">
                    <h3 class="h6">Generated Keys:</h3>
                    <div class="row">
                        <div class="col-md-6">
                            <h4 class="h6">Public Key:</h4>
                            <pre id="publicKey" class="bg-light p-2"></pre>
                        </div>
                        <div class="col-md-6">
                            <h4 class="h6">Private Key:</h4>
                            <pre id="privateKey" class="bg-light p-2"></pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Encryption Section -->
        <div class="card mb-4">
            <div class="card-header">
                <h2 class="h5 mb-0">Encryption</h2>
            </div>
            <div class="card-body">
                <div class="form-group">
                    <label for="messageToEncrypt">Message to Encrypt</label>
                    <textarea class="form-control" id="messageToEncrypt" rows="3"
                        placeholder="Enter message to encrypt..."></textarea>
                </div>
                <button class="btn btn-primary" onclick="encryptMessage()">Encrypt</button>
                <div id="encryptionResult" class="mt-3" style="display: none;">
                    <h3 class="h6">Encrypted Message:</h3>
                    <pre id="encryptedMessage" class="bg-light p-2"></pre>
                </div>
            </div>
        </div>

        <!-- Decryption Section -->
        <div class="card mb-4">
            <div class="card-header">
                <h2 class="h5 mb-0">Decryption</h2>
            </div>
            <div class="card-body">
                <div class="form-group">
                    <label for="messageToDecrypt">Encrypted Message</label>
                    <textarea class="form-control" id="messageToDecrypt" rows="3"
                        placeholder="Enter encrypted message (Base64)..."></textarea>
                </div>
                <button class="btn btn-primary" onclick="decryptMessage()">Decrypt</button>
                <div id="decryptionResult" class="mt-3" style="display: none;">
                    <h3 class="h6">Decrypted Message:</h3>
                    <pre id="decryptedMessage" class="bg-light p-2"></pre>
                </div>
            </div>
        </div>

        <!-- Signing Section -->
        <div class="card mb-4">
            <div class="card-header">
                <h2 class="h5 mb-0">Message Signing</h2>
            </div>
            <div class="card-body">
                <div class="form-group">
                    <label for="messageToSign">Message to Sign</label>
                    <textarea class="form-control" id="messageToSign" rows="3"
                        placeholder="Enter message to sign..."></textarea>
                </div>
                <button class="btn btn-primary" onclick="signMessage()">Sign Message</button>
                <div id="signingResult" class="mt-3" style="display: none;">
                    <h3 class="h6">Signature:</h3>
                    <pre id="signature" class="bg-light p-2"></pre>
                </div>
            </div>
        </div>

        <!-- Verification Section -->
        <div class="card mb-4">
            <div class="card-header">
                <h2 class="h5 mb-0">Signature Verification</h2>
            </div>
            <div class="card-body">
                <div class="form-group">
                    <label for="messageToVerify">Original Message</label>
                    <textarea class="form-control" id="messageToVerify" rows="3"
                        placeholder="Enter original message..."></textarea>
                </div>
                <div class="form-group">
                    <label for="signatureToVerify">Signature</label>
                    <textarea class="form-control" id="signatureToVerify" rows="3"
                        placeholder="Enter signature (Base64)..."></textarea>
                </div>
                <button class="btn btn-primary" onclick="verifySignature()">Verify Signature</button>
                <div id="verificationResult" class="mt-3" style="display: none;">
                    <h3 class="h6">Verification Result:</h3>
                    <pre id="verificationStatus" class="bg-light p-2"></pre>
                </div>
            </div>
        </div>

        <!-- Factorization Attack Section -->
        <div class="card mb-4">
            <div class="card-header">
                <h2 class="h5 mb-0">Factorization Attack</h2>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <div class="form-group">
                            <label for="nToFactor">Modulus (n)</label>
                            <input type="text" class="form-control" id="nToFactor"
                                placeholder="Enter modulus to factor...">
                        </div>
                        <div class="form-group mt-3">
                            <label for="factorMethod">Factorization Method</label>
                            <select class="form-control" id="factorMethod">
                                <option value="auto">Auto (Recommended)</option>
                                <option value="trial">Trial Division</option>
                                <option value="fermat">Fermat</option>
                                <option value="pollard">Pollard's Rho</option>
                                <option value="quadratic">Quadratic Sieve</option>
                                <option value="ecm">Elliptic Curve Method</option>
                            </select>
                        </div>
                        <button class="btn btn-primary mt-3" onclick="factorizeNumber()">Factorize</button>
                    </div>
                    <div class="col-md-6">
                        <div class="method-descriptions">
                            <h6>Method Descriptions:</h6>
                            <div class="method-card">
                                <strong>Trial Division:</strong>
                                <p>Simple method that tries dividing by all numbers up to sqrt(n). Good for small
                                    numbers.</p>
                            </div>
                            <div class="method-card">
                                <strong>Fermat:</strong>
                                <p>Uses the difference of squares. Effective when p and q are close together.</p>
                            </div>
                            <div class="method-card">
                                <strong>Pollard's Rho:</strong>
                                <p>Uses a cycle-finding algorithm. Good for medium-sized numbers.</p>
                            </div>
                            <div class="method-card">
                                <strong>Quadratic Sieve:</strong>
                                <p>Advanced method using smooth numbers. Good for large numbers.</p>
                            </div>
                            <div class="method-card">
                                <strong>Elliptic Curve Method:</strong>
                                <p>Uses elliptic curves. Effective when one factor is small.</p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="loading mt-3" style="display: none;">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-2">Factoring in progress...</p>
                </div>
                <div id="factorizationResult" class="mt-3" style="display: none;">
                    <h3 class="h6">Factorization Result:</h3>
                    <pre id="factorizationOutput" class="bg-light p-2"></pre>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_URL = 'http://localhost:4444/api';
        let currentKeys = null;

        async function generateKeys() {
            const bits = document.getElementById('keySize').value;
            try {
                const response = await fetch(`${API_URL}/generate-keys`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ bits: parseInt(bits) })
                });
                const data = await response.json();
                // Convert all key fields to string to avoid float issues
                if (data.public_key) {
                    data.public_key.n = data.public_key.n.toString();
                    data.public_key.e = data.public_key.e.toString();
                }
                if (data.private_key) {
                    data.private_key.n = data.private_key.n.toString();
                    data.private_key.d = data.private_key.d.toString();
                    data.private_key.p = data.private_key.p.toString();
                    data.private_key.q = data.private_key.q.toString();
                }
                // Copy e from public_key to private_key for signing
                if (data.public_key && data.private_key) {
                    data.private_key.e = data.public_key.e;
                }
                currentKeys = data;

                document.getElementById('publicKey').textContent = JSON.stringify(data.public_key, null, 2);
                document.getElementById('privateKey').textContent = JSON.stringify(data.private_key, null, 2);
                document.getElementById('keyGenerationResult').style.display = 'block';
            } catch (error) {
                alert('Error generating keys: ' + error.message);
            }
        }

        async function signMessage() {
            if (!currentKeys || !currentKeys.private_key) {
                document.getElementById('signature').textContent = 'Error: Please generate keys first or private key is missing!';
                document.getElementById('signingResult').style.display = 'block';
                return;
            }

            const message = document.getElementById('messageToSign').value;
            if (!message) {
                alert('Please enter a message to sign!');
                return;
            }
            // Kiểm tra private_key có đủ trường không
            const priv = currentKeys.private_key;
            if (!priv || !priv.n || !priv.d || !priv.p || !priv.q) {
                alert('Private key is invalid or missing fields!');
                return;
            }
            // Always send as string to avoid float issues
            const privToSend = {
                n: priv.n.toString(),
                e: priv.e.toString(),
                d: priv.d.toString(),
                p: priv.p.toString(),
                q: priv.q.toString()
            };
            try {
                const response = await fetch(`${API_URL}/sign`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: message,
                        private_key: privToSend
                    })
                });
                const data = await response.json();
                if (data.error) {
                    document.getElementById('signature').textContent = 'Error: ' + data.error;
                } else {
                    document.getElementById('signature').textContent = data.signature;
                }
                document.getElementById('signingResult').style.display = 'block';
            } catch (error) {
                document.getElementById('signature').textContent = 'Error signing message: ' + error.message;
                document.getElementById('signingResult').style.display = 'block';
            }
        }

        async function verifySignature() {
            if (!currentKeys || !currentKeys.public_key) {
                document.getElementById('verificationStatus').textContent = 'Error: Please generate keys first or public key is missing!';
                document.getElementById('verificationResult').style.display = 'block';
                return;
            }
            // Trim whitespace from inputs
            const message = document.getElementById('messageToVerify').value.trim();
            const signature = document.getElementById('signatureToVerify').value.trim();

            if (!message || !signature) {
                document.getElementById('verificationStatus').textContent = 'Error: Please enter both message and signature!';
                document.getElementById('verificationResult').style.display = 'block';
                return;
            }

            // Basic check for Base64 format (optional but helpful)
            const base64Regex = /^[A-Za-z0-9+/=]+$/;
            if (!base64Regex.test(signature)) {
                document.getElementById('verificationStatus').textContent = 'Error: Signature does not appear to be valid Base64.';
                document.getElementById('verificationResult').style.display = 'block';
                return;
            }

            // Kiểm tra public_key có đủ trường không
            const pub = currentKeys.public_key;
            if (!pub || !pub.n || !pub.e) {
                document.getElementById('verificationStatus').textContent = 'Error: Public key is invalid or missing fields!';
                document.getElementById('verificationResult').style.display = 'block';
                return;
            }
            // Always send as string to avoid float issues
            const pubToSend = {
                n: pub.n.toString(),
                e: pub.e.toString()
            };
            try {
                const response = await fetch(`${API_URL}/verify`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: message,
                        signature: signature,
                        public_key: pubToSend
                    })
                });
                const data = await response.json();
                // Ensure data.is_valid is a boolean and handle potential errors
                if (data.error) {
                    document.getElementById('verificationStatus').textContent = 'Error: ' + data.error;
                } else if (typeof data.is_valid === 'boolean') {
                    document.getElementById('verificationStatus').textContent =
                        data.is_valid ? 'Signature is valid' : 'Signature is invalid';
                } else {
                    document.getElementById('verificationStatus').textContent = 'Error: Invalid response format from server.';
                }
                document.getElementById('verificationResult').style.display = 'block';
            } catch (error) {
                document.getElementById('verificationStatus').textContent = 'Error verifying signature: ' + error.message;
                document.getElementById('verificationResult').style.display = 'block';
            }
        }

        async function encryptMessage() {
            if (!currentKeys || !currentKeys.public_key) {
                document.getElementById('encryptedMessage').textContent = 'Error: Please generate keys first or public key is missing!';
                document.getElementById('encryptionResult').style.display = 'block';
                return;
            }

            const message = document.getElementById('messageToEncrypt').value;
            if (!message) {
                alert('Please enter a message to encrypt!');
                return;
            }

            const pub = currentKeys.public_key;
            if (!pub || !pub.n || !pub.e) {
                alert('Public key is invalid or missing fields!');
                return;
            }

            const pubToSend = {
                n: pub.n.toString(),
                e: pub.e.toString()
            };

            try {
                const response = await fetch(`${API_URL}/encrypt`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: message,
                        public_key: pubToSend
                    })
                });
                const data = await response.json();
                if (data.error) {
                    document.getElementById('encryptedMessage').textContent = 'Error: ' + data.error;
                } else {
                    document.getElementById('encryptedMessage').textContent = data.encrypted;
                    // Save ciphertext to file
                    try {
                        const saveResponse = await fetch(`${API_URL}/save-ciphertext`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                ciphertext: data.encrypted
                            })
                        });
                        const saveData = await saveResponse.json();
                        if (saveData.success) {
                            console.log('Ciphertext saved to file successfully');
                        }
                    } catch (saveError) {
                        console.error('Error saving ciphertext:', saveError);
                    }
                }
                document.getElementById('encryptionResult').style.display = 'block';
            } catch (error) {
                document.getElementById('encryptedMessage').textContent = 'Error encrypting message: ' + error.message;
                document.getElementById('encryptionResult').style.display = 'block';
            }
        }

        async function decryptMessage() {
            if (!currentKeys || !currentKeys.private_key) {
                document.getElementById('decryptedMessage').textContent = 'Error: Please generate keys first or private key is missing!';
                document.getElementById('decryptionResult').style.display = 'block';
                return;
            }

            const encrypted = document.getElementById('messageToDecrypt').value.trim();
            if (!encrypted) {
                alert('Please enter an encrypted message!');
                return;
            }

            const priv = currentKeys.private_key;
            if (!priv || !priv.n || !priv.d || !priv.p || !priv.q) {
                alert('Private key is invalid or missing fields!');
                return;
            }

            const privToSend = {
                n: priv.n.toString(),
                e: priv.e.toString(),
                d: priv.d.toString(),
                p: priv.p.toString(),
                q: priv.q.toString()
            };

            try {
                const response = await fetch(`${API_URL}/decrypt`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        encrypted: encrypted,
                        private_key: privToSend
                    })
                });
                const data = await response.json();
                if (data.error) {
                    document.getElementById('decryptedMessage').textContent = 'Error: ' + data.error;
                } else {
                    document.getElementById('decryptedMessage').textContent = data.decrypted;
                }
                document.getElementById('decryptionResult').style.display = 'block';
            } catch (error) {
                document.getElementById('decryptedMessage').textContent = 'Error decrypting message: ' + error.message;
                document.getElementById('decryptionResult').style.display = 'block';
            }
        }

        async function factorizeNumber() {
            const n = document.getElementById('nToFactor').value;
            const method = document.getElementById('factorMethod').value;

            if (!n) {
                alert('Please enter a modulus to factor!');
                return;
            }

            // Show loading
            document.querySelector('.loading').style.display = 'block';
            document.getElementById('factorizationResult').style.display = 'none';

            try {
                const response = await fetch(`${API_URL}/factorize`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ n, method })
                });

                const data = await response.json();

                // Hide loading
                document.querySelector('.loading').style.display = 'none';
                document.getElementById('factorizationResult').style.display = 'block';

                // Display result
                const resultContent = document.getElementById('factorizationOutput');
                if (data.success) {
                    resultContent.innerHTML = `
                        <p class="text-success">Factorization successful!</p>
                        <p>Method used: ${data.method}</p>
                        <p>Factors:</p>
                        <ul>
                            <li>p = ${data.factors.p}</li>
                            <li>q = ${data.factors.q}</li>
                        </ul>
                        <p>Execution time: ${data.execution_time.toFixed(3)} seconds</p>
                    `;
                } else {
                    resultContent.innerHTML = `
                        <p class="text-danger">Factorization failed</p>
                        <p>${data.message}</p>
                        <p>Execution time: ${data.execution_time.toFixed(3)} seconds</p>
                    `;
                }
            } catch (error) {
                document.querySelector('.loading').style.display = 'none';
                document.getElementById('factorizationResult').style.display = 'block';
                document.getElementById('factorizationOutput').innerHTML = `
                    <p class="text-danger">Error: ${error.message}</p>
                `;
            }
        }
    </script>
</body>

</html>