<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RSA Demo</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .container {
            max-width: 800px;
        }

        .result-box {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-top: 10px;
            word-break: break-all;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1 class="text-center mb-4">RSA Cryptanalysis Tool</h1>

        <!-- Key Generation Section -->
        <div class="card mb-4">
            <div class="card-header">
                <h2 class="h5 mb-0">RSA Key Generation</h2>
            </div>
            <div class="card-body">
                <p class="text-muted">Get the public key from the server to start encrypting messages.</p>
                <button onclick="generateKeys()" class="btn btn-primary">Get Public Key</button>
                <div id="keyGenerationLoading" class="mt-3" style="display: none;">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <span class="ms-2">Getting public key from server...</span>
                </div>
                <div id="keyGenerationResult" class="mt-3" style="display: none;">
                    <h3 class="h6">Server's Public Key:</h3>
                    <div class="row">
                        <div class="col-md-12">
                            <pre id="publicKey" class="bg-light p-2"></pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Encryption Section -->
        <div class="card mb-4">
            <div class="card-header">
                <h2 class="h5 mb-0">Message Encryption</h2>
            </div>
            <div class="card-body">
                <div class="form-group">
                    <label for="messageToEncrypt">Message to Encrypt</label>
                    <textarea class="form-control" id="messageToEncrypt" rows="3"
                        placeholder="Enter your message here..."></textarea>
                </div>
                <button onclick="encryptMessage()" class="btn btn-primary mt-3">Encrypt Message</button>
                <div id="encryptionResult" class="mt-3" style="display: none;">
                    <h3 class="h6">Encrypted Message:</h3>
                    <pre id="encryptedMessage" class="bg-light p-2"></pre>
                </div>
            </div>
        </div>

        <!-- Message Signing -->
        <div class="card mb-4">
            <div class="card-header">
                <h5 class="mb-0">Server Message Verification</h5>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label class="form-label">Get Signed Message from Server</label>
                    <button class="btn btn-primary" onclick="getSignedMessage()">Get Signed Message</button>
                </div>
                <div class="mb-3">
                    <label class="form-label">Message from Server</label>
                    <textarea class="form-control" id="serverMessage" rows="3" readonly></textarea>
                </div>
                <div class="mb-3">
                    <label class="form-label">Server's Signature</label>
                    <textarea class="form-control" id="serverSignature" rows="3" readonly></textarea>
                </div>
                <div class="mb-3">
                    <label class="form-label">Verify Signature</label>
                    <button class="btn btn-primary" onclick="verifySignature()">Verify Signature</button>
                </div>
                <div class="mb-3">
                    <label class="form-label">Verification Result</label>
                    <div id="verificationResult" class="alert alert-info" style="display: none;"></div>
                </div>
            </div>
        </div>

        <!-- Factorization Attack Section -->
        <div class="card mb-4">
            <div class="card-header">
                <h2 class="h5 mb-0">Factorization Attack</h2>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <div class="form-group">
                            <label for="nToFactor">Modulus (n)</label>
                            <input type="text" class="form-control" id="nToFactor"
                                placeholder="Enter modulus to factor...">
                        </div>
                        <div class="form-group mt-3">
                            <label for="factorMethod">Factorization Method</label>
                            <select class="form-control" id="factorMethod">
                                <option value="auto">Auto (Recommended)</option>
                                <option value="trial">Trial Division</option>
                                <option value="fermat">Fermat</option>
                                <option value="pollard">Pollard's Rho</option>
                                <option value="quadratic">Quadratic Sieve</option>
                                <option value="ecm">Elliptic Curve Method</option>
                            </select>
                        </div>
                        <button class="btn btn-primary mt-3" onclick="factorizeNumber()">Factorize</button>
                    </div>
                    <div class="col-md-6">
                        <div class="method-descriptions">
                            <h6>Method Descriptions:</h6>
                            <div class="method-card">
                                <strong>Trial Division:</strong>
                                <p>Simple method that tries dividing by all numbers up to sqrt(n). Good for small
                                    numbers.</p>
                            </div>
                            <div class="method-card">
                                <strong>Fermat:</strong>
                                <p>Uses the difference of squares. Effective when p and q are close together.</p>
                            </div>
                            <div class="method-card">
                                <strong>Pollard's Rho:</strong>
                                <p>Uses a cycle-finding algorithm. Good for medium-sized numbers.</p>
                            </div>
                            <div class="method-card">
                                <strong>Quadratic Sieve:</strong>
                                <p>Advanced method using smooth numbers. Good for large numbers.</p>
                            </div>
                            <div class="method-card">
                                <strong>Elliptic Curve Method:</strong>
                                <p>Uses elliptic curves. Effective when one factor is small.</p>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="factorizationLoading" class="loading mt-3" style="display: none;">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-2">Factoring in progress...</p>
                </div>
                <div id="factorizationResult" class="mt-3" style="display: none;">
                    <h3 class="h6">Factorization Result:</h3>
                    <pre id="factorizationOutput" class="bg-light p-2"></pre>
                </div>
            </div>
        </div>

        <!-- Timing Attack Section -->
        <div class="card mb-4">
            <div class="card-header">
                <h2 class="h5 mb-0">Timing Attack</h2>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <div class="form-group">
                            <label for="timingN">Modulus (n)</label>
                            <input type="text" class="form-control" id="timingN" placeholder="Enter modulus...">
                        </div>
                        <div class="form-group mt-3">
                            <label for="timingE">Public Exponent (e)</label>
                            <input type="text" class="form-control" id="timingE" placeholder="Enter public exponent...">
                        </div>
                        <div class="form-group mt-3">
                            <label for="timingTrials">Number of Trials</label>
                            <input type="number" class="form-control" id="timingTrials" value="10" min="1" max="100">
                        </div>
                        <button class="btn btn-primary mt-3" onclick="runTimingAttack()">Run Timing Attack</button>
                    </div>
                    <div class="col-md-6">
                        <div class="method-descriptions">
                            <h6>About Timing Attack:</h6>
                            <p>A timing attack is a side-channel attack that exploits timing variations in cryptographic
                                operations.
                                By measuring the time taken to perform decryption operations, an attacker might be able
                                to deduce information about the private key.</p>
                        </div>
                    </div>
                </div>
                <div id="timingLoading" class="loading mt-3" style="display: none;">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-2">Running timing attack...</p>
                </div>
                <div id="timingAttackResult" class="mt-3" style="display: none;">
                    <h3 class="h6">Timing Attack Results:</h3>
                    <div id="timingAttackOutput" class="bg-light p-2"></div>

                    <div id="timingInferenceSection" class="mt-3">
                        <h6 class="h6">Inference Results:</h6>
                        <div id="timingInferenceOutput" class="bg-light p-2"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- CCA Attack Section -->
        <div class="card mb-4">
            <div class="card-header">
                <h2 class="h5 mb-0">Chosen Ciphertext Attack (CCA) - Padding Oracle</h2>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <div class="form-group">
                            <label for="ccaN">Modulus (n)</label>
                            <input type="text" class="form-control" id="ccaN" placeholder="Enter modulus...">
                        </div>
                        <div class="form-group mt-3">
                            <label for="ccaE">Public Exponent (e)</label>
                            <input type="text" class="form-control" id="ccaE" placeholder="Enter public exponent...">
                        </div>
                        <div class="form-group mt-3">
                            <label for="ccaCiphertext">Target Ciphertext</label>
                            <textarea class="form-control" id="ccaCiphertext" rows="3"
                                placeholder="Enter ciphertext to decrypt..."></textarea>
                        </div>
                        <button class="btn btn-primary mt-3" onclick="runCCAAttack()">Run CCA Attack</button>
                    </div>
                    <div class="col-md-6">
                        <div class="method-descriptions">
                            <h6>About Chosen Ciphertext Attack (CCA) - Padding Oracle:</h6>
                            <p>A CCA attack exploits a decryption oracle that leaks information about the validity of
                                padding.
                                By sending specially crafted ciphertexts and observing whether the decryption service
                                returns a valid padding error or not,
                                an attacker can incrementally decrypt the original message.</p>
                            <p>This simulation focuses on a simplified PKCS#1 v1.5 Padding Oracle Attack.</p>
                        </div>
                    </div>
                </div>
                <div id="ccaLoading" class="loading mt-3" style="display: none;">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-2">Running CCA attack...</p>
                </div>
                <div id="ccaResult" class="mt-3" style="display: none;">
                    <h3 class="h6">CCA Attack Results:</h3>
                    <div id="ccaOutput" class="bg-light p-2"></div>
                    <h6 class="h6 mt-3">Attack Log:</h6>
                    <div id="ccaAttackLog" class="bg-light p-2" style="max-height: 300px; overflow-y: scroll;"></div>
                </div>
            </div>
        </div>

        <!-- Wiener Attack Section -->
        <div class="card mb-4">
            <div class="card-header">
                <h2 class="h5 mb-0">Wiener Attack</h2>
            </div>
            <div class="card-body">
                <div class="form-group mt-3">
                    <button class="btn btn-secondary" onclick="generateSmallWienerKey()">Tạo khóa nhỏ demo Wiener
                        Attack</button>
                </div>
                <div class="form-group mt-3">
                    <label for="wienerSmallKeyN">Khóa nhỏ (n):</label>
                    <input type="text" class="form-control" id="wienerSmallKeyN" readonly>
                </div>
                <div class="form-group mt-3">
                    <label for="wienerSmallKeyE">Khóa nhỏ (e):</label>
                    <input type="text" class="form-control" id="wienerSmallKeyE" readonly>
                </div>
                <div class="form-group mt-3">
                    <label for="wienerSmallKeyD">Khóa nhỏ (d):</label>
                    <input type="text" class="form-control" id="wienerSmallKeyD" readonly>
                </div>
                <div class="form-group">
                    <label for="wienerN">Modulus (n)</label>
                    <input type="text" class="form-control" id="wienerN" placeholder="Enter modulus...">
                </div>
                <div class="form-group mt-3">
                    <label for="wienerE">Public Exponent (e)</label>
                    <input type="text" class="form-control" id="wienerE" placeholder="Enter public exponent...">
                </div>
                <button class="btn btn-primary mt-3" onclick="runWienerAttack()">Run Wiener Attack</button>
                <div id="wienerLoading" class="loading mt-3" style="display: none;">
                    <div class="spinner-border text-primary" role="status"></div>
                    <p class="mt-2">Running Wiener attack...</p>
                </div>
                <div id="wienerResult" class="mt-3" style="display: none;">
                    <h3 class="h6">Wiener Attack Results:</h3>
                    <div id="wienerAttackOutput" class="bg-light p-2"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_URL = 'http://localhost:4444/api';
        let currentPublicKey = null;

        async function generateKeys() {
            // Show loading
            document.getElementById('keyGenerationLoading').style.display = 'block';
            document.getElementById('keyGenerationResult').style.display = 'none';

            try {
                const response = await fetch(`${API_URL}/generate-keys`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                const data = await response.json();

                if (data.public_key) {
                    data.public_key.n = data.public_key.n.toString();
                    data.public_key.e = data.public_key.e.toString();
                    currentPublicKey = data.public_key;
                    document.getElementById('publicKey').textContent = JSON.stringify(data.public_key, null, 2);
                    document.getElementById('keyGenerationResult').style.display = 'block';
                } else if (data.error) {
                    document.getElementById('keyGenerationResult').style.display = 'block';
                    document.getElementById('publicKey').textContent = `Error: ${data.error}`;
                }
            } catch (error) {
                document.getElementById('keyGenerationLoading').style.display = 'none';
                document.getElementById('keyGenerationResult').style.display = 'block';
                document.getElementById('publicKey').textContent = `Error: ${error.message}`;
            } finally {
                document.getElementById('keyGenerationLoading').style.display = 'none';
            }
        }

        async function encryptMessage() {
            if (!currentPublicKey) {
                document.getElementById('encryptedMessage').textContent = 'Error: Please get public key from server first!';
                document.getElementById('encryptionResult').style.display = 'block';
                return;
            }

            const message = document.getElementById('messageToEncrypt').value;
            if (!message) {
                alert('Please enter a message to encrypt!');
                return;
            }

            try {
                const response = await fetch(`${API_URL}/encrypt`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: message,
                        public_key: currentPublicKey
                    })
                });
                const data = await response.json();
                if (data.error) {
                    document.getElementById('encryptedMessage').textContent = 'Error: ' + data.error;
                } else {
                    document.getElementById('encryptedMessage').textContent = data.encrypted;
                }
                document.getElementById('encryptionResult').style.display = 'block';
            } catch (error) {
                document.getElementById('encryptedMessage').textContent = 'Error encrypting message: ' + error.message;
                document.getElementById('encryptionResult').style.display = 'block';
            }
        }

        async function getSignedMessage() {
            try {
                const response = await fetch('/api/get-signed-message');
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                document.getElementById('serverMessage').value = data.message;
                document.getElementById('serverSignature').value = data.signature;

                // Show success message
                const resultDiv = document.getElementById('verificationResult');
                resultDiv.className = 'alert alert-success';
                resultDiv.textContent = 'Successfully received signed message from server';
                resultDiv.style.display = 'block';
            } catch (error) {
                console.error('Error getting signed message:', error);
                const resultDiv = document.getElementById('verificationResult');
                resultDiv.className = 'alert alert-danger';
                resultDiv.textContent = `Error: ${error.message}`;
                resultDiv.style.display = 'block';
            }
        }

        async function verifySignature() {
            try {
                const message = document.getElementById('serverMessage').value;
                const signature = document.getElementById('serverSignature').value;

                if (!message || !signature) {
                    throw new Error('Please get a signed message from server first');
                }

                if (!currentPublicKey) {
                    throw new Error('Please get public key first');
                }

                const response = await fetch('/api/verify', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: message,
                        signature: signature
                    })
                });

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                const resultDiv = document.getElementById('verificationResult');
                if (data.is_valid) {
                    resultDiv.className = 'alert alert-success';
                    resultDiv.textContent = 'Signature is valid!';
                } else {
                    resultDiv.className = 'alert alert-danger';
                    resultDiv.textContent = 'Signature is invalid!';
                }
                resultDiv.style.display = 'block';
            } catch (error) {
                console.error('Error verifying signature:', error);
                const resultDiv = document.getElementById('verificationResult');
                resultDiv.className = 'alert alert-danger';
                resultDiv.textContent = `Error: ${error.message}`;
                resultDiv.style.display = 'block';
            }
        }

        async function factorizeNumber() {
            const n = document.getElementById('nToFactor').value;
            const method = document.getElementById('factorMethod').value;

            if (!n) {
                alert('Please enter a modulus (n) to factor!');
                return;
            }

            // Show loading
            document.getElementById('factorizationLoading').style.display = 'block';
            document.getElementById('factorizationResult').style.display = 'none';

            try {
                const response = await fetch(`${API_URL}/factorize`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ n, method })
                });

                const data = await response.json();

                // Hide loading
                document.getElementById('factorizationLoading').style.display = 'none';
                document.getElementById('factorizationResult').style.display = 'block';

                // Display result
                const resultContent = document.getElementById('factorizationOutput');
                if (data.success) {
                    resultContent.innerHTML = `
                        <p class="text-success">Factorization successful!</p>
                        <p>Method used: ${data.method}</p>
                        <p>Factors:</p>
                        <ul>
                            <li>p = ${data.factors.p}</li>
                            <li>q = ${data.factors.q}</li>
                        </ul>
                        <p>Execution time: ${data.execution_time.toFixed(3)} seconds</p>
                    `;
                } else {
                    resultContent.innerHTML = `
                        <p class="text-danger">Factorization failed</p>
                        <p>${data.message}</p>
                        <p>Execution time: ${data.execution_time.toFixed(3)} seconds</p>
                    `;
                }
            } catch (error) {
                document.getElementById('factorizationLoading').style.display = 'none';
                document.getElementById('factorizationResult').style.display = 'block';
                document.getElementById('factorizationOutput').innerHTML = `
                    <p class="text-danger">Error: ${error.message}</p>
                `;
            }
        }

        async function runTimingAttack() {
            const n = document.getElementById('timingN').value;
            const e = document.getElementById('timingE').value;
            const trials = document.getElementById('timingTrials').value;

            if (!n || !e) {
                alert('Please enter both modulus and public exponent!');
                return;
            }

            // Show loading and clear previous results
            document.getElementById('timingLoading').style.display = 'block';
            document.getElementById('timingAttackResult').style.display = 'none';
            document.getElementById('timingAttackOutput').innerHTML = ''; // Clear previous results
            document.getElementById('timingInferenceOutput').innerHTML = ''; // Clear previous inference

            try {
                const response = await fetch(`${API_URL}/timing-attack`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ n, e, trials })
                });

                const data = await response.json();

                // Hide loading
                document.getElementById('timingLoading').style.display = 'none';
                document.getElementById('timingAttackResult').style.display = 'block';

                // Display result
                const resultContent = document.getElementById('timingAttackOutput');
                const inferenceContent = document.getElementById('timingInferenceOutput');

                if (data.success) {
                    let html = `
                        <p class="text-success">Timing attack completed successfully!</p>
                        <h6>Statistics:</h6>
                        <ul>
                            <li>Number of trials: ${data.statistics.trials}</li>
                            <li>Average time: ${data.statistics.average_time.toFixed(8)} seconds</li>
                            <li>Minimum time: ${data.statistics.min_time.toFixed(8)} seconds</li>
                            <li>Maximum time: ${data.statistics.max_time.toFixed(8)} seconds</li>
                            <li>Time variance: ${data.statistics.time_variance.toFixed(8)} seconds</li>
                        </ul>
                        <h6>Detailed Results:</h6>
                        <table class="table table-sm">
                            <thead>
                                <tr>
                                    <th>Trial</th>
                                    <th>Duration (s)</th>
                                    <th>Plaintext</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;

                    data.results.forEach(result => {
                        html += `
                            <tr>
                                <td>${result.trial}</td>
                                <td>${result.duration.toFixed(8)}</td>
                                <td>${result.plaintext}</td>
                            </tr>
                        `;
                    });

                    html += `
                            </tbody>
                        </table>
                        <p>Total execution time: ${data.execution_time.toFixed(3)} seconds</p>
                    `;

                    resultContent.innerHTML = html;

                    // Display inference results
                    if (data.inference) {
                        inferenceContent.innerHTML = `
                            <ul>
                                <li>Target Bit Index: ${data.inference.target_bit_index} (Bit thứ ${data.inference.target_bit_index + 1} của 'd')</li>
                                <li>Actual Bit Value: ${data.inference.actual_bit_value !== null ? data.inference.actual_bit_value : 'N/A'}</li>
                                <li>Inferred Bit Value: ${data.inference.inferred_bit_value !== null ? data.inference.inferred_bit_value : 'N/A'}</li>
                                <li>Inference Correct: <span class="${data.inference.inference_correct ? 'text-success' : 'text-danger'}">${data.inference.inference_correct ? 'Yes' : 'No'}</span></li>
                            </ul>
                        `;
                    } else {
                        inferenceContent.innerHTML = `<p class="text-warning">No inference data available.</p>`;
                    }

                } else {
                    resultContent.innerHTML = `
                        <p class="text-danger">Timing attack failed</p>
                        <p>${data.message}</p>
                    `;
                    inferenceContent.innerHTML = ''; // Clear inference on failure
                }
            } catch (error) {
                document.getElementById('timingLoading').style.display = 'none';
                document.getElementById('timingAttackResult').style.display = 'block';
                document.getElementById('timingAttackOutput').innerHTML = `
                    <p class="text-danger">Error: ${error.message}</p>
                `
            }
        }

        async function runCCAAttack() {
            if (!currentPublicKey) {
                alert('Please generate keys first!');
                return;
            }

            const ciphertext = document.getElementById('ccaCiphertext').value.trim();
            if (!ciphertext) {
                alert('Please enter a ciphertext!');
                return;
            }

            // Show loading
            document.getElementById('ccaLoading').style.display = 'block';
            document.getElementById('ccaResult').style.display = 'none';

            try {
                const response = await fetch(`${API_URL}/cca-attack`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        ciphertext: ciphertext,
                        public_key: currentPublicKey
                    })
                });

                const data = await response.json();

                // Hide loading
                document.getElementById('ccaLoading').style.display = 'none';
                document.getElementById('ccaResult').style.display = 'block';

                if (data.error) {
                    document.getElementById('ccaOutput').textContent = `Error: ${data.error}`;
                    document.getElementById('ccaAttackLog').textContent = '';
                } else {
                    document.getElementById('ccaOutput').textContent = JSON.stringify(data.result, null, 2);
                    if (data.result.attack_log) {
                        // Format the attack_log for better readability
                        const formattedLog = data.result.attack_log.map(entry => {
                            return JSON.stringify(entry, null, 2);
                        }).join('\n\n'); // Join with double newline for separation
                        document.getElementById('ccaAttackLog').textContent = formattedLog;
                    }
                }
            } catch (error) {
                document.getElementById('ccaLoading').style.display = 'none';
                document.getElementById('ccaResult').style.display = 'block';
                document.getElementById('ccaOutput').textContent = `Error: ${error.message}`;
                document.getElementById('ccaAttackLog').textContent = '';
            }
        }

        async function runWienerAttack() {
            const n = document.getElementById('wienerN').value.trim();
            const e = document.getElementById('wienerE').value.trim();
            document.getElementById('wienerLoading').style.display = 'block';
            document.getElementById('wienerResult').style.display = 'none';
            try {
                const response = await fetch(`${API_URL}/wiener-attack`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ n, e })
                });
                const data = await response.json();
                document.getElementById('wienerLoading').style.display = 'none';
                document.getElementById('wienerResult').style.display = 'block';
                document.getElementById('wienerAttackOutput').textContent = JSON.stringify(data.result, null, 2);
            } catch (error) {
                document.getElementById('wienerLoading').style.display = 'none';
                document.getElementById('wienerResult').style.display = 'block';
                document.getElementById('wienerAttackOutput').textContent = `Error: ${error.message}`;
            }
        }

        // Sinh khóa nhỏ dùng cho demo Wiener Attack
        async function generateSmallWienerKey() {
            try {
                const response = await fetch(`${API_URL}/generate-small-wiener-key`);
                const data = await response.json();
                document.getElementById('wienerSmallKeyN').value = data.n;
                document.getElementById('wienerSmallKeyE').value = data.e;
                document.getElementById('wienerSmallKeyD').value = data.d;
            } catch (error) {
                alert('Không thể sinh khóa nhỏ: ' + error.message);
            }
        }

        // Helper function to convert hex to Base64 (for display)
        function hexToBase64(hex) {
            return btoa(String.fromCharCode.apply(null, hex.match(/\w{2}/g).map(function (a) { return parseInt(a, 16); })));
        }
    </script>
</body>

</html>